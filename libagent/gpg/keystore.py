"""Storage for information needed to regenerate GPG private keys."""

import binascii
import logging
import os

import trio

from . import client, protocol, util

log = logging.getLogger(__name__)


async def store_key(c, user_id, curve_name, ecdh, created, homedir, open_file=trio.open_file):
    """Stores the specified key parameters into a matching file in the keystore.

    The file name is based on the keygrip generated from the specified key parameters.
    Returns the generated public key object for the key parameters.
    """
    # pylint: disable=too-many-arguments
    assert curve_name in protocol.SUPPORTED_CURVES
    identity = client.create_identity(user_id=user_id, curve_name=curve_name)
    verifying_key = await c.pubkey(identity=identity, ecdh=ecdh)
    pubkey = protocol.PublicKey(
        curve_name=curve_name, created=created,
        verifying_key=verifying_key, ecdh=ecdh)
    keygrip = util.hexlify(pubkey.keygrip())
    keydir = os.path.join(homedir, 'private-keys-v1.d')
    await trio.Path(keydir).mkdir(mode=0o700, parents=True, exist_ok=True)
    async with await open_file(os.path.join(keydir, '{0}.key'.format(keygrip)), 'w') as f:
        await f.write('Path: {0}\n'.format(util.hexlify(user_id.encode('utf-8'))))
        await f.write('Curve: {0}\n'.format(curve_name))
        await f.write('ECDH: {0}\n'.format('True' if ecdh else 'False'))
        await f.write('Created: {0}\n'.format(created))
    await trio.Path(f.name).chmod(0o700)
    return pubkey


async def load_key(c, keygrip, homedir, open_file=trio.open_file):
    """Loads the key matching the specified keygrip from the keystore.

    Verifies that the loaded parameters match a key generated with the current device.
    Returns a dictionary containing the parameters used to generate the key,
    as well as the identity and public key generated from the key.
    """
    user_id = None
    curve_name = None
    ecdh = None
    created = None
    keyfile = os.path.join(homedir, 'private-keys-v1.d', '{0}.key'.format(util.hexlify(keygrip)))
    try:
        async with await open_file(keyfile, 'r') as f:
            async for line in f:
                if line.startswith('Path: '):
                    try:
                        user_id = binascii.unhexlify(line[6:-1].encode('ascii')).decode('utf-8')
                    except binascii.Error:
                        pass
                    except UnicodeDecodeError:
                        pass
                elif line.startswith('Curve: '):
                    curve_name = line[7:-1]
                elif line == 'ECDH: True\n':
                    ecdh = True
                elif line == 'ECDH: False\n':
                    ecdh = False
                elif line.startswith('Created: '):
                    created = int(line[9:-1])
    except IOError as e:
        raise KeyError('key file "{0}" could not be read'.format(keyfile)) from e
    if user_id is None or curve_name is None or ecdh is None or created is None:
        raise KeyError('key file "{0}" is corrupt or incomplete'.format(keyfile))
    if curve_name not in protocol.SUPPORTED_CURVES:
        raise KeyError('key file "{0}" has invalid curve name "{1}"'.format(keyfile, curve_name))
    identity = client.create_identity(user_id=user_id, curve_name=curve_name)
    verifying_key = await c.pubkey(identity=identity, ecdh=ecdh)
    pubkey = protocol.PublicKey(
        curve_name=curve_name, created=created,
        verifying_key=verifying_key, ecdh=ecdh)
    if keygrip != pubkey.keygrip():
        # Sanity check: If the key file is invalid, or was generated by a different device, fail
        raise KeyError(
            'key file "{0}" generated mismatched keygrip "{1}". Did you use the wrong device?'
            .format(keyfile, util.hexlify(pubkey.keygrip())))
    return {
        'user_id': user_id,
        'curve_name': curve_name,
        'ecdh': ecdh,
        'created': created,
        'identity': identity,
        'verifying_key': verifying_key,
        'pubkey': pubkey
    }


async def delete_key(keygrip, homedir, trio_path=trio.Path):
    """Deletes the key matching the specified key grip from the key store."""
    keyfile = os.path.join(homedir, 'private-keys-v1.d', '{0}.key'.format(util.hexlify(keygrip)))
    await trio_path(keyfile).unlink()


async def list_keys(c, homedir, open_file=trio.open_file, trio_path=trio.Path):
    """Lists all available keys in the key store."""
    result = []
    keyglob = os.path.join(homedir, 'private-keys-v1.d')
    for keyfile in await trio_path(keyglob).glob('*.key'):
        try:
            keygrip = binascii.unhexlify(keyfile.stem)
            # Actually testing the keys takes too long. Better to return it unconditionally.
            # await load_key(c, keygrip, homedir, open_file)
            result.append(keygrip)
        except Exception as e:  # pylint: disable=broad-except
            log.warning('Invalid key file "%s" in key store: %s', keyfile, e)
    return result
